# Age Verification via Zero-Knowledge Proofs

This project demonstrates how Zero-Knowledge Proofs can be applied to a real-world privacy problem: proving that a user is at least 18 years old without revealing their actual age or date of birth.

The implementation uses **Groth16 zk-SNARKs** (Circom + snarkjs). The proof is generated entirely in the user's browser — the server never sees the birthdate.

---

## Motivation

Traditional age verification requires sending personal data (date of birth, ID scans) to a server. This creates centralized repositories of sensitive information that become targets for data breaches.

Zero-Knowledge Proofs offer an alternative: the user proves a statement ("I am over 18") mathematically, without disclosing the underlying data. The server learns exactly one bit of information — yes or no — and nothing else.

---

## How It Works

```
Browser                                    Server
───────────────────────────────────        ──────────────────────
User enters date of birth locally
JS computes age = today - birthdate
snarkjs.groth16.fullProve(
  { age, threshold: 18 },         
  age_check.wasm,                  
  circuit_final.zkey               
)
                                   →  receives: { proof, publicSignals: ["18"] }
                                      runs: snarkjs.groth16.verify(vk, ...)
                                   ←  returns: { verified: true/false }
```

The birthdate is computed and used locally. Only a 256-byte cryptographic proof leaves the browser.

---

## Project Structure

```
demonstration/
├── circuit/
│   ├── age_check.circom       — ZK circuit (Circom 2.0)
│   ├── setup.sh               — trusted setup script (run once)
│   └── package.json
├── backend/
│   ├── main.py                — FastAPI server (verifier only)
│   ├── requirements.txt
│   └── verification_key.json  — generated by setup.sh
└── frontend/
    ├── public/
    │   ├── age_check.wasm     — generated by setup.sh
    │   └── circuit_final.zkey — generated by setup.sh
    ├── src/
    │   ├── App.jsx
    │   ├── main.jsx
    │   └── index.css
    ├── index.html
    ├── package.json
    └── vite.config.js
```

---

## Setup and Running

### Step 1 — Install Circom compiler

Download the pre-built binary from the releases page:
https://github.com/iden3/circom/releases/latest

On Windows: download `circom-windows-amd64.exe`, rename it to `circom.exe` and place it in `C:\Windows\System32\`.

Verify:
```bash
circom --version
```

### Step 2 — Trusted Setup (run once)

This step compiles the circuit and generates the cryptographic keys.

```bash
cd circuit
npm install
bash setup.sh
```

It takes about 2–3 minutes. When finished, the following files are created automatically:
- `frontend/public/age_check.wasm` — WASM prover loaded by the browser
- `frontend/public/circuit_final.zkey` — proving key
- `backend/verification_key.json` — verification key used by the server

### Step 3 — Start the backend

```bash
cd backend
pip install -r requirements.txt
uvicorn main:app --reload --port 8000
```

API available at http://localhost:8000  
Interactive docs at http://localhost:8000/docs

### Step 4 — Start the frontend

```bash
cd frontend
npm install
npm run dev
```

Open http://localhost:5173

---

## The Circuit

The circuit is written in Circom 2.0 and uses primitives from the circomlib library.

### Why Num2Bits is necessary

Signals in Circom are elements of the finite field ℤ_p where p ≈ 2^254 (the BN128 scalar field order). This means arithmetic is modular, not integer arithmetic.

Without range checks, a malicious prover could exploit this. For example:

```
age = 0, threshold = 18
delta = 0 - 18 ≡ p - 18 (mod p)
```

The value p − 18 is a large positive number in the field. A naive comparison would incorrectly conclude that age ≥ threshold.

The solution is to apply `Num2Bits(n)` to the delta signal. This component decomposes a number into its binary representation and only succeeds if the value fits in n bits — which means it must be in the range [0, 2^n − 1]. If delta is negative (i.e., age < threshold), it becomes a huge field element that cannot be represented in 7 bits, so the constraint system has no valid solution and proof generation fails.

### Constraint structure

```circom
// Constrain age to [0, 127]
component ageRange = Num2Bits(7);
ageRange.in <== age;

// Constrain threshold to [0, 31]
component threshRange = Num2Bits(5);
threshRange.in <== threshold;

// Compute delta (private signal, verifier never sees it)
signal delta;
delta <== age - threshold;

// Main range proof: delta must be in [0, 127]
// This is equivalent to proving age >= threshold
component deltaRange = Num2Bits(7);
deltaRange.in <== delta;

// Explicit comparator (safe here because ranges are already bounded above)
component gte = GreaterEqThan(8);
gte.in[0] <== age;
gte.in[1] <== threshold;
gte.out === 1;
```

The circuit has approximately 44 constraints, which is small enough that proof generation in the browser takes under 500ms.

---

## Groth16 Verification

The verifier checks a single equation involving bilinear pairings on the BN128 elliptic curve:

```
e(A, B) = e(α, β) · e( Σ wᵢ · ICᵢ , γ ) · e(C, δ)
```

where A, B, C come from the proof, α, β, γ, δ and IC come from the verification key, and wᵢ are the public inputs (in our case, threshold = 18). The function e(·, ·) is the optimal Ate pairing.

This check runs in constant time — three pairing operations — regardless of the size of the circuit. The server does not need any private data to perform it.

---

## Security Analysis

### Cryptographic assumptions

Groth16 security rests on three assumptions:

**q-Strong Diffie-Hellman (q-SDH):** Given (g, g^τ, g^τ², ..., g^τ^q) in both G1 and G2, it is computationally infeasible to produce a pair (c, g^(1/(τ+c))). This assumption underlies soundness — a prover cannot forge a valid proof without a valid witness.

**Bilinear Diffie-Hellman Problem (BDHP):** Given (g^a, g^b, g^c), it is infeasible to compute e(g, g)^(abc). This underlies the zero-knowledge property.

**Generic Group Model (GGM):** The security proof for Groth16 is carried out in the Generic Group Model, which treats group operations as ideal. In practice this is an assumption, not a theorem — real-world groups may have structure that GGM does not capture.

BN128 currently offers approximately 128-bit security and is used in production systems including Ethereum (EIP-197) and Zcash.

### Limitations

The protocol proves a mathematical statement about a witness known to the prover. It does not verify that the date of birth entered by the user is genuine. It does not authenticate the identity of the user. It does not prevent the same proof from being replayed. These are separate concerns that would require additional mechanisms (e.g., identity binding, nullifiers via Poseidon hash).

---

## Trusted Setup

Groth16 requires a one-time ceremony to generate the proving key. During this process, a secret value τ (tau) is used and must be destroyed afterward. If τ is retained by any participant, they can generate valid proofs for false statements — including proofs that an underage user is over 18 — and the verifier has no way to detect this.

This is known as the "toxic waste" problem.

In this implementation, the setup is performed by a single party, which is acceptable for a research demonstration. A production deployment would require a multi-party computation ceremony where τ is split among multiple independent parties, so that the setup is compromised only if all parties collude.

Public trusted setups suitable for production use are available from the Hermez Network (Powers of Tau) and the Zcash parameter generation ceremony.

---

## Threat Model

**What the proof establishes:**  
The prover knows an integer `age` such that `age ∈ [0, 127]` and `age ≥ 18`.

**What the verifier learns:**  
Only that the above statement is true. The exact value of age, the delta (age − 18), and the date of birth remain unknown.

**Attack vectors outside ZK:**

| Vector | Description | Mitigation |
|--------|-------------|------------|
| Trusted setup compromise | τ retained → forged proofs | Multi-party ceremony |
| Verification key substitution | Replaced vk on server → accepts any proof | Publish vk hash, check on deploy |
| WASM/zkey substitution | Replaced files in browser → wrong circuit | Subresource Integrity (SRI) in HTML |
| False input by user | User enters wrong birthdate | Out of scope for ZK — separate problem |
| Network interception | MITM on proof transmission | HTTPS |

---

## ZK Properties

| Property | Guarantee | Assumption |
|----------|-----------|------------|
| Zero-Knowledge | Verifier learns only `age ≥ 18` | BDHP on BN128 |
| Completeness | Honest prover always succeeds | Unconditional |
| Soundness | Forgery is computationally infeasible | q-SDH on BN128, honest setup |
| Succinctness | Proof is 256 bytes, verification is O(1) | Groth16 architecture |
